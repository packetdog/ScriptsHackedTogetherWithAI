<#
    LCS Dropbox Monitor / Restart
    Version: v1.00p
    Generated by ChatGPT GPT-5.1 Thinking on 11/24/2025 @ 09:07 AM CST
    Feedback/Contact: info@packetdog.net

    GOAL: This script was created due to Dropbox introducing an apparent bug in their mid-November 2025 update,
          versioned as v239.x, where they seem to have overhauled the client UI and layout. This new client
          started to crash multiple times a day only fixed by restarting or manually launching the Dropbox
          app from a users logged in environment. This would immediately cause sync issues between the
          workstations, proving difficult for hte average user to diagnose. The script checks for Dropbox.exe
          processes and restarts them if not running, including logging and reporting. Hopefully Dropbox will
          correct this in the future which will cause the client not to crash, and the script to stop emailing.

    NOTE:
    - This script is intended to be scheduled and run by RMM/in SYSTEM context (for example, every 15 minutes).
    - Task Scheduler is used ONLY as a one-time vehicle to start Dropbox.exe
      in the logged-on user context when it is NOT running, using the COM API (no schtasks CLI).
    - No recurring scheduled tasks are created for monitoring.
    - When Dropbox is restarted, it is monitored for 60 seconds:
        * If it stays running for the full 60 seconds, subject indicates a successful restart.
        * If it crashes again within 60 seconds, subject indicates that the client crashed again.
    - Script creates a log on the device every time it runs (up to X lines, see var below) showing the status of each run.
    - If a restart of the Dropbox client occurs, it will also generate an email to you to let you know, although this can be commented out.

    - We've had this deployed for over a week with a client that uses Dropbox heavily at their business. This
      restarts the Dropbox client on all machines at least once a day. We get a tidy email when it does.
#>

#region Config

# Comma-separated list of workstation names to skip (example: 'PC1,PC2,LAPTOP-01')
# If the current workstation name matches one of these, the script will exit immediately
# with no logging or output.
$ignoredWorkstations = ''

# Force log file path to be the same on all machines
$LogFilePath  = 'C:\Windows\Temp\DropboxCheck.log'
$MaxLogLines  = 1500

# Dropbox path and startup arguments.
# Default path; adjust if needed.
$DropboxExePath = 'C:\Program Files (x86)\Dropbox\Client\Dropbox.exe'
$DropboxArgs    = '/systemstartup'

# Timing (seconds)
$WaitForStartSeconds     = 60    # How long to wait for a new Dropbox process to appear
$MonitorDurationSeconds  = 60    # Monitor new Dropbox root process for 60 seconds
$MonitorCheckIntervalSec = 10    # How often to re-check during the 60 seconds

# Email / SMTP settings
$MailTo       = 'support@somemsp.com' # Email Address to Receive Notifications To
$MailFrom     = 'notifications@somemsp.com'  # Email Address to Receive Notifications From
$SmtpServer   = 'mail.smtp2go.com'
$SmtpPort     = 587
$SmtpUser     = 'dropboxscript_smtpuser'
$SmtpPassword = 'dontguessthispassword'

#endregion Config

#region Helpers

# Buffer for all on-screen log messages so we can include them in the email
$script:RunLogBuffer = @()

function Write-DropboxLog {
    param(
        [string]$Message
    )
    # Verbose output for RMM / console
    Write-Host $Message

    # Store for email body
    try {
        if ($null -eq $script:RunLogBuffer) {
            $script:RunLogBuffer = @()
        }
        $script:RunLogBuffer += $Message
    }
    catch {
        # Ignore buffer failures
    }
}

function Write-DropboxSummaryLog {
    param(
        [string]$SummaryMessage
    )

    try {
        $timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        $line = "[{0}] {1}" -f $timestamp, $SummaryMessage

        # Ensure directory exists (it should, but just in case)
        $logDir = Split-Path -Path $LogFilePath -Parent
        if (-not (Test-Path $logDir)) {
            New-Item -Path $logDir -ItemType Directory -Force | Out-Null
        }

        # Append summary line
        Add-Content -Path $LogFilePath -Value $line

        # Trim log to last $MaxLogLines lines
        if (Test-Path $LogFilePath) {
            $allLines = Get-Content -Path $LogFilePath
            if ($allLines.Count -gt $MaxLogLines) {
                $startIndex = [Math]::Max(0, $allLines.Count - $MaxLogLines)
                $endIndex   = $allLines.Count - 1
                $trimmed    = $allLines[$startIndex..$endIndex]
                Set-Content -Path $LogFilePath -Value $trimmed
            }
        }
    }
    catch {
        # Do not break script on log failure
    }
}

function Convert-ToDateSafe {
    param(
        [Parameter(Mandatory = $false)]
        [object]$Value
    )

    if ($null -eq $Value) {
        return $null
    }

    if ($Value -is [datetime]) {
        return $Value
    }

    try {
        $s = [string]$Value

        # DMTF datetime format (typical for WMI): yyyymmddHHMMSS.mmmmmmsUUU
        if ($s -match '^\d{14}\.\d{6}(\+|\-)\d{3}$') {
            return [System.Management.ManagementDateTimeConverter]::ToDateTime($s)
        }

        # Fallback to normal DateTime parsing
        return [datetime]::Parse($s)
    }
    catch {
        return $null
    }
}

function Get-LastBootTime {
    try {
        $os = Get-CimInstance -ClassName Win32_OperatingSystem
        return $os.LastBootUpTime
    }
    catch {
        return $null
    }
}

function Get-DropboxProcesses {
    # Use CIM to get access to CommandLine etc.
    try {
        return Get-CimInstance -ClassName Win32_Process -Filter "Name = 'Dropbox.exe'"
    }
    catch {
        return @()
    }
}

function Get-DropboxRootProcess {
    param(
        [array]$DropboxProcesses
    )

    if (-not $DropboxProcesses -or $DropboxProcesses.Count -eq 0) {
        return $null
    }

    # Prefer the one with /systemstartup in the command line
    $rootCandidates = $DropboxProcesses | Where-Object {
        $_.CommandLine -like '*/systemstartup*'
    }

    if (-not $rootCandidates -or $rootCandidates.Count -eq 0) {
        # Fallback: earliest CreationDate
        return ($DropboxProcesses | Sort-Object CreationDate | Select-Object -First 1)
    }
    else {
        return ($rootCandidates | Sort-Object CreationDate | Select-Object -First 1)
    }
}

function Get-LoggedOnUser {
    try {
        $cs = Get-CimInstance -ClassName Win32_ComputerSystem
        return $cs.UserName  # DOMAIN\User or COMPUTER\User or $null
    }
    catch {
        return $null
    }
}

function Get-ProcessSnapshot {
    try {
        $procs = Get-Process | Sort-Object ProcessName, Id
        $lines = @()

        $lines += ("TotalProcesses={0}" -f $procs.Count)
        $lines += "ProcessName,Id,SessionId,StartTime"

        foreach ($p in $procs) {
            $start = $null
            try {
                $start = $p.StartTime
            }
            catch {
                $start = "<unknown>"
            }
            $lines += ("{0},{1},{2},{3}" -f $p.ProcessName, $p.Id, $p.SessionId, $start)
        }

        return ($lines -join [Environment]::NewLine)
    }
    catch {
        return "Unable to capture process list snapshot: $($_.Exception.Message)"
    }
}

function Send-DropboxEmail {
    param(
        [string]$Subject,
        [string]$Body
    )

    if ([string]::IsNullOrWhiteSpace($SmtpUser) -or
        [string]::IsNullOrWhiteSpace($SmtpPassword)) {

        Write-DropboxLog "Email not sent: SMTP credentials are not configured."
        return $false
    }

    try {
        Write-DropboxLog ("Sending email notification to {0} via {1}:{2} ..." -f $MailTo, $SmtpServer, $SmtpPort)

        $securePwd = ConvertTo-SecureString $SmtpPassword -AsPlainText -Force
        $cred = New-Object System.Management.Automation.PSCredential ($SmtpUser, $securePwd)

        Send-MailMessage -SmtpServer $SmtpServer `
                         -Port $SmtpPort `
                         -UseSsl `
                         -Credential $cred `
                         -From $MailFrom `
                         -To $MailTo `
                         -Subject $Subject `
                         -Body $Body

        Write-DropboxLog "Notification email sent to $MailTo with subject: $Subject"
        return $true
    }
    catch {
        Write-DropboxLog "Failed to send email: $($_.Exception.Message)"
        return $false
    }
}

function Start-DropboxAsUser {
    param(
        [string]$ExePath,
        [string]$Arguments,
        [string]$RunAsUser   # DOMAIN\User or COMPUTER\User
    )

    Write-DropboxLog "Preparing to start Dropbox as user '$RunAsUser' using '$ExePath' $Arguments"

    if (-not (Test-Path $ExePath)) {
        Write-DropboxLog "Dropbox.exe not found at '$ExePath'."
        return $false
    }

    if ([string]::IsNullOrWhiteSpace($RunAsUser)) {
        Write-DropboxLog "No interactive user detected; cannot schedule Dropbox restart in user context."
        return $false
    }

    try {
        $service = New-Object -ComObject 'Schedule.Service'
        $service.Connect()
        $root = $service.GetFolder('\')

        $taskDef = $service.NewTask(0)
        $taskDef.RegistrationInfo.Description = 'LCS Dropbox one-time restart'

        # Principal settings: run as the logged-on user, interactive token
        $taskDef.Principal.UserId    = $RunAsUser
        $taskDef.Principal.LogonType = 3  # TASK_LOGON_INTERACTIVE_TOKEN
        $taskDef.Principal.RunLevel  = 1  # TASK_RUNLEVEL_HIGHEST

        # One-time trigger a few seconds in the future
        $trigger = $taskDef.Triggers.Create(1)  # TIME_TRIGGER_ONE_TIME
        $trigger.StartBoundary = (Get-Date).AddSeconds(5).ToString("yyyy-MM-dd'T'HH:mm:ss")
        $trigger.Enabled       = $true

        # Exec action: Dropbox.exe with arguments
        $action           = $taskDef.Actions.Create(0)  # TASK_ACTION_EXEC
        $action.Path      = $ExePath
        $action.Arguments = $Arguments

        $taskName = 'LCS_Dropbox_Restart'
        Write-DropboxLog "Registering COM scheduled task '$taskName' for $RunAsUser..."

        # 6 = TASK_CREATE_OR_UPDATE
        $null = $root.RegisterTaskDefinition(
            $taskName,
            $taskDef,
            6,
            $null,
            $null,
            3,    # TASK_LOGON_INTERACTIVE_TOKEN
            $null
        )

        $task = $root.GetTask($taskName)
        Write-DropboxLog "Running COM scheduled task '$taskName'..."
        $null = $task.Run($null)

        Start-Sleep -Seconds 2

        Write-DropboxLog "Deleting COM scheduled task '$taskName'..."
        $root.DeleteTask($taskName, 0)

        Write-DropboxLog "COM scheduled task '$taskName' created, run, and deleted successfully."
        return $true
    }
    catch {
        Write-DropboxLog "Failed to create/run COM scheduled task: $($_.Exception.Message)"
        return $false
    }
}

#endregion Helpers

#region Main logic

# Determine workstation name and enforce ignore list BEFORE any logging/output
$computerName = $env:COMPUTERNAME

if (-not [string]::IsNullOrWhiteSpace($ignoredWorkstations)) {
    $ignoredList = $ignoredWorkstations -split '\s*,\s*' | Where-Object { $_ }
    if ($ignoredList -contains $computerName) {
        # Silent, immediate exit for ignored workstations
        exit 0
    }
}

Write-Host "Log file: $LogFilePath"

$now = Get-Date

Write-DropboxLog "Starting LCS Dropbox monitor script on $computerName. Log file path: $LogFilePath"

$lastBootRaw  = Get-LastBootTime
$lastBootDt   = Convert-ToDateSafe $lastBootRaw
$lastBootString = if ($lastBootDt) { $lastBootDt } else { '<unknown>' }
Write-DropboxLog "Last boot time: $lastBootString"

$loggedOnUser = Get-LoggedOnUser
$loggedOnUserString = if ($loggedOnUser) { $loggedOnUser } else { '<none>' }
Write-DropboxLog "Logged-on user: $loggedOnUserString"

# NEW: If no interactive user is logged on, Dropbox cannot run properly.
# In that case, log and exit with no email.
if (-not $loggedOnUser) {
    $overallStatus    = 'NO_USER'
    $initialProcCount = 0
    $finalProcCount   = 0
    $rootPid          = '<none>'
    $newRootPid       = '<none>'
    $mainUptime       = 'N/A'
    $restartRequested = $false
    $restartSucceeded = $false
    $stayedRunning    = $false

    Write-DropboxLog "No interactive user is currently logged on. Dropbox client requires a logged-on user. Exiting with no restart and no email."

    $emailStatus = 'Skipped'
    $summary = ("{0} | STATUS={1} | InitProcs={2} | FinalProcs={3} | MainPID={4} | MainUptime={5} | NewPID={6} | Boot={7} | User={8} | RestartReq={9} | RestartOK={10} | Stayed={11} | Email={12}" -f `
        $computerName,
        $overallStatus,
        $initialProcCount,
        $finalProcCount,
        $rootPid,
        $mainUptime,
        $newRootPid,
        $lastBootString,
        $loggedOnUserString,
        $restartRequested,
        $restartSucceeded,
        $stayedRunning,
        $emailStatus)

    Write-DropboxSummaryLog $summary
    return
}

Write-DropboxLog "Checking for existing Dropbox.exe processes..."

# Tracking fields for summary line
$initialProcCount = 0
$finalProcCount   = 0
$overallStatus    = 'UNKNOWN'
$rootPid          = '<none>'
$newRootPid       = '<none>'
$mainUptime       = 'N/A'
$restartRequested = $false
$restartSucceeded = $false
$stayedRunning    = $false
$emailAttempted   = $false
$emailSucceeded   = $false

# Get existing Dropbox processes
$dropboxProcs = Get-DropboxProcesses
$initialProcCount = $dropboxProcs.Count
$dropboxRoot  = Get-DropboxRootProcess -DropboxProcesses $dropboxProcs

if ($dropboxProcs.Count -gt 0) {
    Write-DropboxLog ("Found {0} Dropbox.exe process(es)." -f $dropboxProcs.Count)
} else {
    Write-DropboxLog "No Dropbox.exe processes found."
}

if ($dropboxRoot) {
    # Dropbox is running; just log and exit
    $rootStartDt = Convert-ToDateSafe $dropboxRoot.CreationDate
    $uptime      = [TimeSpan]::Zero
    if ($rootStartDt) {
        $uptime = $now - $rootStartDt
    }

    $rootPid       = $dropboxRoot.ProcessId
    $mainUptime    = $uptime.ToString()
    $overallStatus = 'RUNNING'

    $msg = "Dropbox is running. MainPID={0}, DropboxProcesses={1}, MainStarted={2}, MainUptime={3}, LastBoot={4}, LoggedOnUser={5}" -f `
        $dropboxRoot.ProcessId,
        $dropboxProcs.Count,
        ($rootStartDt -as [string]),
        $mainUptime,
        $lastBootString,
        $loggedOnUserString

    Write-DropboxLog $msg
    Write-DropboxLog "Dropbox is running; no further action required this run."

    # Final proc count same as initial
    $finalProcCount = $initialProcCount

    # Single-line summary to file (no email sent in this case)
    $emailStatus = 'Skipped'
    $summary = ("{0} | STATUS={1} | InitProcs={2} | FinalProcs={3} | MainPID={4} | MainUptime={5} | NewPID={6} | Boot={7} | User={8} | RestartReq={9} | RestartOK={10} | Stayed={11} | Email={12}" -f `
        $computerName,
        $overallStatus,
        $initialProcCount,
        $finalProcCount,
        $rootPid,
        $mainUptime,
        $newRootPid,
        $lastBootString,
        $loggedOnUserString,
        $restartRequested,
        $restartSucceeded,
        $stayedRunning,
        $emailStatus)

    Write-DropboxSummaryLog $summary
    return
}

# Dropbox is NOT running
Write-DropboxLog "Dropbox is NOT running. No Dropbox.exe processes found. LastBoot=$lastBootString, LoggedOnUser=$loggedOnUserString"
$overallStatus = 'NOT_RUNNING'

# Try to locate Dropbox.exe if the default path is not present
if (-not (Test-Path $DropboxExePath)) {
    try {
        Write-DropboxLog "Default Dropbox path '$DropboxExePath' not found; searching Program Files for Dropbox.exe..."
        $candidate = Get-ChildItem -Path "$env:ProgramFiles*\Dropbox" -Filter 'Dropbox.exe' -Recurse -ErrorAction SilentlyContinue |
                     Select-Object -First 1
        if ($candidate) {
            $DropboxExePath = $candidate.FullName
            Write-DropboxLog "Using discovered Dropbox path: $DropboxExePath"
        }
        else {
            Write-DropboxLog "Unable to find Dropbox.exe under Program Files or Program Files (x86)."
        }
    }
    catch {
        Write-DropboxLog "Error searching for Dropbox.exe: $($_.Exception.Message)"
    }
}
else {
    Write-DropboxLog "Using configured Dropbox path: $DropboxExePath"
}

# Attempt restart
Write-DropboxLog "Attempting to restart Dropbox via one-time COM scheduled task..."
$restartRequested = $true
$restartSucceeded = Start-DropboxAsUser -ExePath $DropboxExePath -Arguments $DropboxArgs -RunAsUser $loggedOnUser

$newRootProc   = $null
$stayedRunning = $false

if ($restartSucceeded) {

    Write-DropboxLog "Dropbox restart requested successfully. Waiting up to $WaitForStartSeconds seconds for a new Dropbox main process..."

    # Wait for Dropbox to start (new main process)
    $startDeadline = (Get-Date).AddSeconds($WaitForStartSeconds)
    do {
        Start-Sleep -Seconds 5
        $dropboxProcsAfter = Get-DropboxProcesses
        $newRootProc       = Get-DropboxRootProcess -DropboxProcesses $dropboxProcsAfter
    } while (-not $newRootProc -and (Get-Date) -lt $startDeadline)

    if (-not $newRootProc) {
        Write-DropboxLog "Dropbox restart was requested but no Dropbox main process appeared within $WaitForStartSeconds seconds."
        $overallStatus = 'RESTART_NO_PROCESS'
    }
    else {
        $rootStartNewDt = Convert-ToDateSafe $newRootProc.CreationDate
        $newRootPid     = $newRootProc.ProcessId

        Write-DropboxLog ("Dropbox restart detected. New main PID={0}, MainStarted={1}" -f `
            $newRootProc.ProcessId,
            ($rootStartNewDt -as [string]))

        # Monitor for 60 seconds to ensure it stays running
        Write-DropboxLog "Monitoring new Dropbox main PID=$($newRootProc.ProcessId) for $MonitorDurationSeconds seconds..."
        $monitorEnd = (Get-Date).AddSeconds($MonitorDurationSeconds)
        $stayedRunning = $true

        while ((Get-Date) -lt $monitorEnd) {
            Start-Sleep -Seconds $MonitorCheckIntervalSec

            $check = Get-CimInstance -ClassName Win32_Process -Filter ("ProcessId = {0}" -f $newRootProc.ProcessId) -ErrorAction SilentlyContinue
            if (-not $check) {
                Write-DropboxLog "New Dropbox main PID=$($newRootProc.ProcessId) terminated before monitoring window completed."
                $stayedRunning = $false
                break
            }
        }

        if ($stayedRunning) {
            Write-DropboxLog "New Dropbox main PID=$($newRootProc.ProcessId) remained running for the full monitoring window ($MonitorDurationSeconds seconds)."
            $overallStatus = 'RESTART_OK'
        }
        else {
            Write-DropboxLog "New Dropbox main PID=$($newRootProc.ProcessId) did not stay running for the full monitoring window."
            $overallStatus = 'RESTART_UNSTABLE'
        }
    }
}
else {
    Write-DropboxLog "Dropbox restart attempt failed (COM scheduled task could not be created or run)."
    $overallStatus = 'RESTART_FAILED'
}

# Build and send email notification

Write-DropboxLog "Building email notification payload..."

$processSnapshot = Get-ProcessSnapshot

# Choose a descriptive subject based on what happened
if (-not $restartSucceeded) {
    $subjectStatusText = "Restart failed (could not create or run task)"
}
elseif (-not $newRootProc) {
    $subjectStatusText = "Restart attempted; no new Dropbox process started"
}
elseif (-not $stayedRunning) {
    $subjectStatusText = "Restart attempted; Dropbox crashed again within 60 seconds"
}
else {
    $subjectStatusText = "Restart successful; Dropbox running for at least 60 seconds"
}

$subject = "Dropbox monitor on $computerName - $subjectStatusText"

$bodyLines = @()
$bodyLines += "Dropbox monitor notification"
$bodyLines += ""
$bodyLines += "Timestamp:       $now"
$bodyLines += "Computer:        $computerName"
$bodyLines += "Logged-on user:  $loggedOnUserString"
$bodyLines += "Last boot time:  $lastBootString"
$bodyLines += ""
$bodyLines += "Status summary:"
$bodyLines += "  Overall status:     $overallStatus"
$bodyLines += "  Restart requested:  $restartRequested"
$bodyLines += "  Restart succeeded:  $restartSucceeded"
$bodyLines += "  New main PID:       $newRootPid"
$bodyLines += "  Stayed running 60s: $stayedRunning"
$bodyLines += ""
$bodyLines += "On-screen log for this run:"
foreach ($line in $script:RunLogBuffer) {
    $bodyLines += "  $line"
}
$bodyLines += ""
$bodyLines += "Process summary (CSV style):"
$bodyLines += $processSnapshot

$body = ($bodyLines -join [Environment]::NewLine)

$emailAttempted = $true
$emailSucceeded = Send-DropboxEmail -Subject $subject -Body $body

# Refresh final process count for summary
$finalProcCount = (Get-DropboxProcesses).Count

# Build single-line summary for the file log
$emailStatus =
    if (-not $emailAttempted) { 'Skipped' }
    elseif ($emailSucceeded) { 'Sent' }
    else { 'Failed' }

$summary = ("{0} | STATUS={1} | InitProcs={2} | FinalProcs={3} | MainPID={4} | MainUptime={5} | NewPID={6} | Boot={7} | User={8} | RestartReq={9} | RestartOK={10} | Stayed={11} | Email={12}" -f `
    $computerName,
    $overallStatus,
    $initialProcCount,
    $finalProcCount,
    $rootPid,
    $mainUptime,
    $newRootPid,
    $lastBootString,
    $loggedOnUserString,
    $restartRequested,
    $restartSucceeded,
    $stayedRunning,
    $emailStatus)

Write-DropboxSummaryLog $summary

Write-DropboxLog "Script run completed."

#endregion Main logic
